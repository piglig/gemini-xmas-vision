<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR é‡‘è‰²ç²’å­åœ£è¯æ ‘</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* éšè—çš„è§†é¢‘å…ƒç´ ï¼Œç”¨äºè®¡ç®—æœºè§†è§‰å¤„ç† */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 240px;
            opacity: 0; 
            z-index: 0;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 24px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #FFD700;
            z-index: 20;
            transition: opacity 0.5s;
        }

        .hud-top {
            padding: 20px;
            text-align: center;
            color: rgba(255, 215, 0, 0.9);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .hud-status {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .hud-instruction {
            font-size: 14px;
            color: #ccc;
        }

        #gesture-icon {
            font-size: 40px;
            display: block;
            margin-top: 10px;
            height: 50px;
        }

        /* å¤§å›¾å±•ç¤ºè¦†ç›–å±‚ */
        #overlay-image-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 80%;
            max-width: 500px;
            aspect-ratio: 16/9;
            background: #000;
            border: 2px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            border-radius: 15px;
            overflow: hidden;
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s;
            z-index: 15;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #overlay-image-container.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        #overlay-content {
            color: #FFD700;
            font-size: 20px;
            text-align: center;
        }
        
        .photo-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #1a1a1a, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        /* è°ƒè¯•çª—å£ï¼ˆå¯é€‰ï¼Œå·¦ä¸‹è§’ï¼‰ */
        #debug-log {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: lime;
            font-size: 12px;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            max-width: 300px;
            pointer-events: none;
        }

        /* æ‰‹åŠ¿æŒ‡ç¤ºå™¨ */
        #gesture-indicator {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: none;
        }

        .gesture-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        .gesture-dot.active {
            background: #FFD700;
            border-color: #FFD700;
            box-shadow: 0 0 15px #FFD700;
        }

        /* ç¥ç¦åŠ¨ç”»å®¹å™¨ */
        #blessing-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #blessing-container.active {
            opacity: 1;
        }

        .blessing-text {
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8),
                         0 0 40px rgba(255, 215, 0, 0.6),
                         0 0 60px rgba(255, 215, 0, 0.4);
            animation: blessingPulse 2s ease-in-out;
            text-align: center;
        }

        @keyframes blessingPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* æ‰‹åŠ¿è¿½è¸ªå…‰æ ‡ */
        #hand-cursor {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 3px solid #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 12;
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s ease-out;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        #hand-cursor.visible {
            opacity: 1;
        }

        #hand-cursor.pinching {
            transform: scale(0.6);
            background: rgba(255, 215, 0, 0.5);
        }

        /* éŸ³ä¹æ§åˆ¶æŒ‰é’® */
        #music-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #FFD700;
            color: #FFD700;
            font-size: 24px;
            cursor: pointer;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        #music-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.1);
        }

        #music-btn.playing {
            animation: musicPulse 1s ease-in-out infinite;
        }

        @keyframes musicPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

        /* éŸ³ä¹æç¤º */
        #music-hint {
            position: absolute;
            bottom: 80px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #FFD700;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            white-space: nowrap;
        }

        #music-btn:hover + #music-hint,
        #music-hint.show {
            opacity: 1;
        }
    </style>
    
    <!-- Scripts will be loaded dynamically based on IP location -->
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ– AR å¼•æ“...<br><span style="font-size:14px; color:#ccc;">è¯·å…è®¸ä½¿ç”¨æ‘„åƒå¤´</span></div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-status" id="status-text">çŠ¶æ€: ç­‰å¾…æ‰‹åŠ¿</div>
            <div class="hud-instruction" id="instruction-text">è¯·å°†æ‰‹æŒæ”¾å…¥æ‘„åƒå¤´è§†é‡</div>
            <div id="gesture-icon">âœ‹</div>
        </div>
        <div id="debug-log">åˆå§‹åŒ–...</div>
    </div>

    <!-- æåˆæ—¶å±•ç¤ºçš„å¤§å›¾ -->
    <div id="overlay-image-container">
        <img id="overlay-image" src="" alt="Memory" style="max-width: 100%; max-height: 100%; object-fit: contain;">
    </div>

    <!-- æ‰‹åŠ¿è¿½è¸ªå…‰æ ‡ -->
    <div id="hand-cursor"></div>

    <!-- æ‰‹åŠ¿æŒ‡ç¤ºå™¨ -->
    <div id="gesture-indicator">
        <div class="gesture-dot" id="dot-hand" title="æ‰‹æŒæ£€æµ‹"></div>
        <div class="gesture-dot" id="dot-move" title="ç§»åŠ¨æ§åˆ¶"></div>
        <div class="gesture-dot" id="dot-closed" title="é—­åˆæ‰‹åŠ¿"></div>
    </div>

    <!-- ç¥ç¦åŠ¨ç”» -->
    <div id="blessing-container">
        <div class="blessing-text" id="blessing-text"></div>
    </div>

    <!-- éŸ³ä¹æ§åˆ¶ -->
    <button id="music-btn" title="æ’­æ”¾/æš‚åœéŸ³ä¹">ğŸ”‡</button>
    <div id="music-hint">ç‚¹å‡»æ’­æ”¾åœ£è¯éŸ³ä¹</div>

    <script>
        // --- 0. åŠ¨æ€èµ„æºåŠ è½½é€»è¾‘ ---
        const CDN_SOURCES = {
            CN: {
                three: "https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js",
                mediapipe: {
                    camera: "https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js",
                    control: "https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js",
                    drawing: "https://npm.elemecdn.com/@mediapipe/drawing_utils/drawing_utils.js",
                    hands: "https://npm.elemecdn.com/@mediapipe/hands/hands.js",
                    assets: "https://npm.elemecdn.com/@mediapipe/hands/" // ç”¨äº locateFile
                }
            },
            GLOBAL: {
                three: "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js",
                mediapipe: {
                    camera: "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
                    control: "https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js",
                    drawing: "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js",
                    hands: "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                    assets: "https://cdn.jsdelivr.net/npm/@mediapipe/hands/" // ç”¨äº locateFile
                }
            }
        };

        let mpAssetBase = ""; // MediaPipe èµ„æºåŸºè·¯å¾„

        async function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.crossOrigin = "anonymous";
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        async function initEnvironment() {
            const loadingEl = document.getElementById('loading');
            loadingEl.innerHTML = "æ­£åœ¨æ£€æµ‹ç½‘ç»œç¯å¢ƒ...";
            
            let config = CDN_SOURCES.GLOBAL; // é»˜è®¤å…¨çƒæº
            
            try {
                // ç®€å•çš„ IP åœ°ç†ä½ç½®æ£€æŸ¥
                // ä½¿ç”¨ ipapi.co (æœ‰å…è´¹é¢åº¦) æˆ–è€…å…¶ä»–ç±»ä¼¼æœåŠ¡
                const res = await fetch('https://ipapi.co/json/', { signal: AbortSignal.timeout(3000) });
                if (res.ok) {
                    const data = await res.json();
                    console.log("Detected Location:", data.country_code);
                    if (data.country_code === 'CN') {
                        config = CDN_SOURCES.CN;
                    }
                }
            } catch (e) {
                console.warn("IP check failed, falling back to CN source for safety (better accessibility in CN than Global in CN).", e);
                // å¦‚æœæ£€æµ‹è¶…æ—¶æˆ–å¤±è´¥ï¼Œä¸ºäº†ä¿è¯ä¸­å›½ç”¨æˆ·ï¼ˆæœ€å¯èƒ½å—é™çš„ç¾¤ä½“ï¼‰èƒ½ç”¨ï¼Œ
                // æ¿€è¿›ç­–ç•¥æ˜¯å›é€€åˆ° CN æºï¼Œå› ä¸º ElemeCDN åœ¨å›½å¤–é€šå¸¸ä¹Ÿèƒ½è®¿é—®ï¼Œåªæ˜¯æ…¢ä¸€ç‚¹ï¼›
                // ä½† jsDelivr åœ¨å›½å†…æ˜¯å®Œå…¨æŒ‚çš„ã€‚
                config = CDN_SOURCES.CN;
            }

            loadingEl.innerHTML = `æ­£åœ¨åŠ è½½æ ¸å¿ƒåº“...<br><span style="font-size:12px;color:#aaa">Source: ${config === CDN_SOURCES.CN ? 'China Mirror' : 'Global CDN'}</span>`;
            
            mpAssetBase = config.mediapipe.assets;

            try {
                // å¹¶è¡ŒåŠ è½½ Three.js å’Œ MediaPipe åŸºç¡€åº“
                await Promise.all([
                    loadScript(config.three),
                    loadScript(config.mediapipe.camera),
                    loadScript(config.mediapipe.control),
                    loadScript(config.mediapipe.drawing),
                    loadScript(config.mediapipe.hands)
                ]);
                console.log("All scripts loaded.");
            } catch (e) {
                loadingEl.innerHTML = "æ ¸å¿ƒåº“åŠ è½½å¤±è´¥<br>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥";
                console.error("Script load error:", e);
                throw e;
            }
        }

        // --- 1. å…¨å±€å˜é‡ä¸é…ç½® ---
        const CONFIG = {
            colors: {
                // æ ‘å¶é¢œè‰²
                darkGreen: 0x0D5C0D,
                green: 0x228B22,
                lightGreen: 0x32CD32,
                // ç¯é¥°é¢œè‰²
                gold: 0xFFD700,
                warmWhite: 0xFFFDD0,
                red: 0xFF4444,
                blue: 0x4488FF,
                silver: 0xC0C0C0,
                // å…¶ä»–
                darkGold: 0xB8860B,
                brown: 0x8B4513,
                starYellow: 0xFFFF00
            },
            treeHeight: 20,
            treeRadius: 8,
            particleCount: 5500,  // å¢åŠ ç²’å­æ•°é‡
            ornamentCount: 18,    // å½©çƒæ•°é‡
            lightCount: 60,       // å½©ç¯æ•°é‡
            snowflakeCount: 800   // é›ªèŠ±æ•°é‡
        };

        // æœ¬åœ°å›¾ç‰‡åˆ—è¡¨
        const PHOTOS = []; // å°†ç”± autoDetectPhotos è‡ªåŠ¨å¡«å……
        let currentPhotoIndex = 0;

        let scene, camera, renderer;
        let treeParticles, starParticles;
        let spiralGroup;
        let particleSystem;
        let ornaments = [];       // å½©çƒè£…é¥°
        let lightString;          // å½©ç¯ä¸²
        let giftBoxes = [];       // ç¤¼ç‰©ç›’
        let rotatingLight;        // æ—‹è½¬å…‰æº
        let clock;
        
        // çŠ¶æ€ç®¡ç†
        const STATE = {
            IDLE: 'IDLE',          // æ— æ‰‹åŠ¿ï¼šè¿œæ™¯
            INTERACTIVE: 'INTERACTIVE', // æ‰‹æŒå‡ºç°ï¼šäº¤äº’æ¨¡å¼
            CLOSED: 'CLOSED'       // æåˆæˆ–æ¡æ‹³ï¼šæ”¾æ…¢é›ªèŠ±+å±•ç¤ºå›¾ç‰‡
        };
        let currentState = STATE.IDLE;

        // æ‰‹åŠ¿ç›¸å…³
        let handVisible = false;
        let isHandOpen = false;
        let isPinching = false;
        let handX = 0.5;
        let handY = 0.5;
        let prevHandX = 0.5;
        let prevHandY = 0.5;
        let swipeDeltaX = 0;
        let swipeDeltaY = 0;

        // æŒ¥æ‰‹æ£€æµ‹
        let waveHistory = [];
        let lastWaveTime = 0;
        let isWaving = false;

        // é›ªèŠ±åŠ é€Ÿæ§åˆ¶
        let snowSpeedMultiplier = 1;
        let targetSnowSpeed = 1;

        // æ‘„åƒæœºæ§åˆ¶
        let targetCameraZ = 35;
        let targetCameraY = 10;
        let targetGroupRotation = 0;

        // ç¥ç¦è¯­
        const blessings = [
            "Merry Christmas!",
            "åœ£è¯å¿«ä¹!",
            "Happy Holidays!",
            "æ–°å¹´å¿«ä¹!",
            "Peace & Joy"
        ];
        let blessingIndex = 0;

        // DOM å…ƒç´ 
        const statusEl = document.getElementById('status-text');
        const instructionEl = document.getElementById('instruction-text');
        const iconEl = document.getElementById('gesture-icon');
        const overlayEl = document.getElementById('overlay-image-container');
        const debugEl = document.getElementById('debug-log');
        const loadingEl = document.getElementById('loading');
        const handCursor = document.getElementById('hand-cursor');
        const dotHand = document.getElementById('dot-hand');
        const dotMove = document.getElementById('dot-move');
        const dotClosed = document.getElementById('dot-closed');
        const blessingContainer = document.getElementById('blessing-container');
        const blessingTextEl = document.getElementById('blessing-text');
        const musicBtn = document.getElementById('music-btn');
        const musicHint = document.getElementById('music-hint');
        const overlayImage = document.getElementById('overlay-image');

        // éŸ³ä¹ç›¸å…³
        let bgMusic = null;
        let isMusicPlaying = false;
        let audioContext = null;

        // --- 2. Three.js åˆå§‹åŒ–ä¸åœºæ™¯æ„å»º ---
        
        function initScene() {
            const container = document.getElementById('canvas-container');

            clock = new THREE.Clock(); // åˆå§‹åŒ–æ—¶é’Ÿ
            spiralGroup = new THREE.Group(); // åˆå§‹åŒ–èºæ—‹ç»„

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // å¢å¼ºå…‰ç…§
            const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
            scene.add(ambientLight);

            // ä¸»å…‰æº - ä»ä¸Šæ–¹ç…§å°„
            const mainLight = new THREE.PointLight(CONFIG.colors.warmWhite, 1.2, 80);
            mainLight.position.set(0, 25, 15);
            scene.add(mainLight);

            // æ—‹è½¬å…‰æº - å›´ç»•æ ‘æ—‹è½¬
            rotatingLight = new THREE.PointLight(CONFIG.colors.gold, 0.8, 50);
            rotatingLight.position.set(15, 10, 0);
            scene.add(rotatingLight);

            // åº•éƒ¨è¡¥å…‰
            const bottomLight = new THREE.PointLight(0x4466aa, 0.4, 40);
            bottomLight.position.set(0, -5, 20);
            scene.add(bottomLight);

            // åˆ›å»ºå†…å®¹ - æŒ‰é¡ºåºåˆ›å»º
            createParticleTree();
            createTreeTrunk();
            createStar();
            createOrnaments();
            createLightString();
            createGiftBoxes();
            createSpiralPhotos();
            createBackgroundParticles();

            // ç›‘å¬çª—å£å¤§å°
            window.addEventListener('resize', onWindowResize, false);
        }

        // åˆ›å»ºç²’å­åœ£è¯æ ‘
        function createParticleTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const colorObj = new THREE.Color();

            // æ ‘å¶ç²’å­ - ä½¿ç”¨æ›´èŒ‚å¯†çš„åˆ†å¸ƒ
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // ä¿®æ”¹åˆ†å¸ƒæŒ‡æ•°: 0.7 -> 1.5
                // Math.random() æ˜¯ 0-1
                // å¹‚ > 1 ä¼šè®©ç»“æœæ›´åå‘ 0 (åº•éƒ¨)
                // å¹‚ < 1 ä¼šè®©ç»“æœæ›´åå‘ 1 (é¡¶éƒ¨)
                const heightRatio = Math.pow(Math.random(), 1.5); 
                const y = heightRatio * CONFIG.treeHeight;

                // æ ‘çš„å½¢çŠ¶ï¼šåº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–ï¼Œæ·»åŠ å±‚æ¬¡æ„Ÿ
                const baseRadius = CONFIG.treeRadius * (1 - heightRatio * 0.95);
                // æ·»åŠ "æ ‘æ"å±‚æ¬¡æ„Ÿ
                const layerEffect = Math.sin(heightRatio * Math.PI * 8) * 0.3 + 1;
                const radius = baseRadius * layerEffect * (0.3 + Math.random() * 0.7);

                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                positions.push(x, y, z);

                // é¢œè‰²åˆ†é…ï¼š90% ç»¿è‰²æ ‘å¶ï¼Œ10% å½©ç¯
                const rand = Math.random();
                if (rand > 0.90) {
                    // å½©ç¯ - å¤šç§é¢œè‰²
                    const lightColors = [CONFIG.colors.gold, CONFIG.colors.warmWhite, CONFIG.colors.red, CONFIG.colors.blue];
                    colorObj.setHex(lightColors[Math.floor(Math.random() * lightColors.length)]);
                    sizes.push(0.5 + Math.random() * 0.3);
                } else {
                    // ç»¿è‰²æ ‘å¶ - æ¸å˜è‰²
                    const greenColors = [CONFIG.colors.darkGreen, CONFIG.colors.green, CONFIG.colors.lightGreen];
                    const greenIndex = Math.floor(Math.random() * greenColors.length);
                    colorObj.setHex(greenColors[greenIndex]);
                    sizes.push(0.2 + Math.random() * 0.15);
                }

                colors.push(colorObj.r, colorObj.g, colorObj.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.35,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                map: createCircleTexture()
            });

            treeParticles = new THREE.Points(geometry, material);

            const treeGroup = new THREE.Group();
            treeGroup.add(treeParticles);

            scene.add(treeGroup);
            scene.userData.treeGroup = treeGroup;
        }

        // åˆ›å»ºæ ‘å¹² (ç²’å­ç‰¹æ•ˆç‰ˆ)
        function createTreeTrunk() {
            const treeGroup = scene.userData.treeGroup;
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const colorObj = new THREE.Color();

            const trunkCount = 2000; // ç²’å­æ•°é‡

            for (let i = 0; i < trunkCount; i++) {
                // é«˜åº¦èŒƒå›´ï¼š0 åˆ° -6 (æ ‘æ ¹æ·±ä¸€ç‚¹)
                const h = Math.random() * 6; 
                const y = -h * 0.8; // ç¨å¾®å‹ç¼©ä¸€ä¸‹é«˜åº¦

                // æ ‘å¹²å½¢çŠ¶ï¼šä¸Šç»†ä¸‹ç²— (æ¨¡æ‹Ÿæ ‘æ ¹è”“å»¶)
                // åŸºç¡€åŠå¾„ 0.8
                // éšç€æ·±åº¦å¢åŠ ï¼ŒåŠå¾„æŒ‡æ•°çº§æ‰©å¤§
                const spread = Math.pow(h / 6, 2) * 4; 
                const radius = 0.8 + spread + Math.random() * 0.4;
                
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                positions.push(x, y, z);

                // é¢œè‰²ï¼šæ·±è¤è‰²ä¸ºä¸»ï¼Œæ··åˆé‡‘è‰²èƒ½é‡ç²’å­
                if (Math.random() > 0.85) {
                    colorObj.setHex(CONFIG.colors.gold); // é‡‘è‰²é«˜å…‰
                    sizes.push(0.4 + Math.random() * 0.2);
                } else {
                    colorObj.setHex(0x5C4033); // æ·±è¤è‰²
                    // é¢œè‰²å¾®è°ƒï¼Œé¿å…å•è°ƒ
                    colorObj.r *= (0.8 + Math.random() * 0.4);
                    colorObj.g *= (0.8 + Math.random() * 0.4);
                    colorObj.b *= (0.8 + Math.random() * 0.4);
                    sizes.push(0.25 + Math.random() * 0.15);
                }
                
                colors.push(colorObj.r, colorObj.g, colorObj.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                blending: THREE.AdditiveBlending, // å‘å…‰æ•ˆæœ
                depthWrite: false,
                transparent: true,
                opacity: 0.8,
                map: createCircleTexture()
            });

            const trunkParticles = new THREE.Points(geometry, material);
            treeGroup.add(trunkParticles);
        }

        // åˆ›å»ºæ ‘é¡¶ç²’å­äº”è§’æ˜Ÿ
        function createStar() {
            const treeGroup = scene.userData.treeGroup;
            
            const starParticleCount = 400; // æ„æˆäº”è§’æ˜Ÿçš„ç²’å­æ•°é‡
            const starBaseRadius = 2.0;    // äº”è§’æ˜Ÿçš„æ•´ä½“å¤§å°
            const starCenterY = CONFIG.treeHeight + 0.5; // æ”¾ç½®åœ¨æ ‘é¡¶ä½ç½®ï¼Œç•¥é«˜äºæœ€é«˜ç²’å­

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const colorObj = new THREE.Color();

            for (let i = 0; i < starParticleCount; i++) {
                // åœ¨ XY å¹³é¢ï¼ˆå‚ç›´ï¼‰ç”Ÿæˆæ˜Ÿå½¢ç²’å­
                const angle = Math.random() * Math.PI * 2;
                let radius = Math.random() * starBaseRadius;
                
                // ç®€å•çš„æ˜Ÿå½¢æ•´å½¢é€»è¾‘ï¼šå°†ç²’å­æ¨å‘æ˜Ÿå½¢çš„å°–è§’
                const numPoints = 5;
                const innerRadiusRatio = 0.4; 
                
                const segmentAngle = Math.PI * 2 / numPoints;
                const halfSegmentAngle = segmentAngle / 2;
                
                const angleInSegment = (angle % segmentAngle + segmentAngle) % segmentAngle; 
                let distanceFromSegmentCenter = Math.abs(angleInSegment - halfSegmentAngle);
                distanceFromSegmentCenter = distanceFromSegmentCenter / halfSegmentAngle;
                
                const currentStarRadius = THREE.MathUtils.lerp(starBaseRadius * innerRadiusRatio, starBaseRadius, 1 - distanceFromSegmentCenter);
                radius = Math.random() * currentStarRadius;

                // ä½ç½®ï¼šX å’Œ Y æ„æˆäº†æ˜Ÿå½¢ï¼ŒZ æä¾›äº†å¾®å°æ·±åº¦ (å¢åŠ åšåº¦ä»¥åŒ¹é…æ ‘çš„ä½“ç§¯æ„Ÿ)
                const x = Math.cos(angle) * radius;
                const y_offset = Math.sin(angle) * radius; 
                const z_depth = (Math.random() - 0.5) * 0.8; 

                positions.push(x, starCenterY + y_offset, z_depth);

                // é¢œè‰²ï¼šäº®é»„è‰²å’Œé‡‘è‰²æ··åˆ
                if (Math.random() > 0.7) {
                    colorObj.setHex(CONFIG.colors.gold);
                } else {
                    colorObj.setHex(CONFIG.colors.starYellow);
                }
                colors.push(colorObj.r, colorObj.g, colorObj.b);

                sizes.push(0.5 + Math.random() * 0.8); // è°ƒæ•´å°ºå¯¸
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            geometry.userData.initialPositions = positions.slice();
            geometry.userData.initialSizes = sizes.slice();

            const material = new THREE.PointsMaterial({
                size: 0.5, 
                vertexColors: true,
                blending: THREE.AdditiveBlending, 
                depthWrite: false, 
                transparent: true,
                opacity: 0.9,
                map: createCircleTexture() // ä½¿ç”¨ä¸æ ‘å¶ç›¸åŒçš„çº¹ç†
            });

            starParticles = new THREE.Points(geometry, material);
            // ä¸å†éœ€è¦æ—‹è½¬ï¼Œå› ä¸ºç²’å­å·²åœ¨ XY å¹³é¢ï¼ˆå‚ç›´ï¼‰ç”Ÿæˆ
            treeGroup.add(starParticles);
        }

        let ornamentParticles; // å…¨å±€å˜é‡æ›¿ä»£ ornaments æ•°ç»„

        // åˆ›å»ºå½©çƒè£…é¥° (ç²’å­å‘å…‰ç‰ˆ)
        function createOrnaments() {
            const treeGroup = scene.userData.treeGroup;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const phases = []; // ç”¨äºåŠ¨ç”»ç›¸ä½
            
            const ornamentColors = [CONFIG.colors.red, CONFIG.colors.gold, CONFIG.colors.blue, CONFIG.colors.silver];
            const colorObj = new THREE.Color();

            for (let i = 0; i < CONFIG.ornamentCount; i++) {
                const heightRatio = 0.1 + Math.random() * 0.75;
                const y = heightRatio * CONFIG.treeHeight;
                const maxRadius = CONFIG.treeRadius * (1 - heightRatio * 0.9) * 0.85;
                const angle = (i / CONFIG.ornamentCount) * Math.PI * 2 + Math.random() * 0.5;
                const radius = maxRadius * (0.7 + Math.random() * 0.3);

                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                positions.push(x, y, z);

                // é¢œè‰²
                const color = ornamentColors[i % ornamentColors.length];
                colorObj.setHex(color);
                colors.push(colorObj.r, colorObj.g, colorObj.b);

                // å¤§å°ï¼šæ¯”æ™®é€šç²’å­å¤§å¾ˆå¤šï¼Œå½¢æˆ"çƒ"çš„æ„Ÿè§‰ï¼Œå¹¶å¸¦å…‰æ™•
                sizes.push(1.5 + Math.random() * 1.0);

                // åŠ¨ç”»ç›¸ä½
                phases.push(Math.random() * Math.PI * 2);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));

            // ä¿å­˜åŸå§‹Yä½ç½®ç”¨äºåŠ¨ç”»
            geometry.userData.originalPositions = positions.slice();

            const material = new THREE.PointsMaterial({
                size: 1.0, // åŸºç¡€å¤§å°ï¼Œä¼šè¢« attribute è¦†ç›–å¦‚æœæ”¯æŒï¼Œæˆ–è€…ä½œä¸ºç¼©æ”¾å› å­
                vertexColors: true,
                blending: THREE.AdditiveBlending, // å¼ºå…‰å åŠ 
                depthWrite: false, // ä¸é®æŒ¡
                transparent: true,
                opacity: 0.9,
                map: createGlowTexture() // å¤ç”¨å‘å…‰çº¹ç†
            });

            ornamentParticles = new THREE.Points(geometry, material);
            treeGroup.add(ornamentParticles);
        }

        // åˆ›å»ºå½©ç¯ä¸²
        function createLightString() {
            const treeGroup = scene.userData.treeGroup;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const lightColors = [CONFIG.colors.red, CONFIG.colors.gold, CONFIG.colors.blue, CONFIG.colors.warmWhite, CONFIG.colors.lightGreen];
            const colorObj = new THREE.Color();

            for (let i = 0; i < CONFIG.lightCount; i++) {
                const t = i / CONFIG.lightCount;
                const y = t * CONFIG.treeHeight * 0.9 + 1;
                const spiralAngle = t * Math.PI * 6; // 3åœˆèºæ—‹
                const radius = CONFIG.treeRadius * (1 - t * 0.85) * 1.05;

                const x = Math.cos(spiralAngle) * radius;
                const z = Math.sin(spiralAngle) * radius;

                positions.push(x, y, z);
                colorObj.setHex(lightColors[i % lightColors.length]);
                colors.push(colorObj.r, colorObj.g, colorObj.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                map: createGlowTexture()
            });

            lightString = new THREE.Points(geometry, material);
            treeGroup.add(lightString);
        }

        // åˆ›å»ºç¤¼ç‰©ç›’
        function createGiftBoxes() {
            const treeGroup = scene.userData.treeGroup;
            const giftColors = [
                { box: 0xCC0000, ribbon: 0xFFD700 },
                { box: 0x0066CC, ribbon: 0xFFFFFF },
                { box: 0x228B22, ribbon: 0xFF4444 },
                { box: 0x9932CC, ribbon: 0xFFD700 },
                { box: 0xFFD700, ribbon: 0xCC0000 }
            ];

            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2 + 0.3;
                const distance = 4 + Math.random() * 2;
                const size = 0.8 + Math.random() * 0.6;

                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;

                // ç¤¼ç‰©ç›’ä¸»ä½“
                const boxGeometry = new THREE.BoxGeometry(size, size * 0.8, size);
                const boxMaterial = new THREE.MeshBasicMaterial({
                    color: giftColors[i].box,
                    transparent: true,
                    opacity: 0.9
                });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.set(x, -2.6 + size * 0.4, z);
                box.rotation.y = Math.random() * 0.5;
                box.userData.originalY = box.position.y;
                box.userData.phase = Math.random() * Math.PI * 2;

                // è´è¶ç»“/ä¸å¸¦
                const ribbonH = new THREE.Mesh(
                    new THREE.BoxGeometry(size * 1.1, size * 0.1, size * 0.15),
                    new THREE.MeshBasicMaterial({ color: giftColors[i].ribbon })
                );
                ribbonH.position.y = size * 0.4;
                box.add(ribbonH);

                const ribbonV = new THREE.Mesh(
                    new THREE.BoxGeometry(size * 0.15, size * 0.1, size * 1.1),
                    new THREE.MeshBasicMaterial({ color: giftColors[i].ribbon })
                );
                ribbonV.position.y = size * 0.4;
                box.add(ribbonV);

                treeGroup.add(box);
                giftBoxes.push(box);
            }
        }

        // åˆ›å»ºå‘å…‰çº¹ç†
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const center = 32;
            const radius = 30;

            const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,200,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,200,100,0.4)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        let spiralPhotoObjects = []; // å­˜å‚¨ç…§ç‰‡å¯¹è±¡ä»¥ä¾¿æŸ¥æ‰¾æœ€è¿‘çš„ä¸€ä¸ª

        // åˆ›å»ºèºæ—‹ç…§ç‰‡å¢™ (ä½¿ç”¨çœŸå®å›¾ç‰‡)
        function createSpiralPhotos() {
            scene.add(spiralGroup);
            spiralPhotoObjects = []; // é‡ç½®

            const textureLoader = new THREE.TextureLoader();
            const photoCount = PHOTOS.length;

            // è°ƒè¯•è¾“å‡º
            const debugLog = document.getElementById('debug-log');
            if(debugLog) debugLog.innerHTML += '<br>Loading photos...';

            for (let i = 0; i < photoCount; i++) {
                const photoGroup = new THREE.Group(); // ä½¿ç”¨ç»„æ¥åŒ…å«ç…§ç‰‡å’Œè¾¹æ¡†

                // 1. ç…§ç‰‡å¹³é¢ (æ­£é¢)
                const geometry = new THREE.PlaneGeometry(4, 3);
                
                // åŠ è½½çœŸå®å›¾ç‰‡çº¹ç†
                const texture = textureLoader.load(
                    PHOTOS[i],
                    (tex) => { 
                        console.log('Texture loaded:', PHOTOS[i]); 
                        // å­˜å‚¨å›¾ç‰‡å®½é«˜æ¯”ï¼Œç”¨äºåç»­ UI å±•ç¤º
                        if (tex.image) {
                            photoGroup.userData.aspectRatio = tex.image.width / tex.image.height;
                        }
                    },
                    undefined,
                    (err) => {
                        console.error('Error loading texture:', PHOTOS[i], err);
                        if(debugLog) debugLog.innerHTML += `<br>Err: ${PHOTOS[i]}`;
                    }
                );
                texture.minFilter = THREE.LinearFilter;

                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.FrontSide, // åªæ¸²æŸ“æ­£é¢ï¼Œé¿å…èƒŒé¢é•œåƒå›°æ‰°
                    transparent: true,
                    opacity: 0.9,
                    color: 0xffffff
                });

                const plane = new THREE.Mesh(geometry, material);
                // PlaneGeometry é»˜è®¤æ³•çº¿æœ +Z
                photoGroup.add(plane);

                // 2. ç…§ç‰‡èƒŒæ¿ (èƒŒé¢)
                // ä¸ºäº†è®©ç”¨æˆ·åœ¨èƒŒé¢ä¹Ÿèƒ½çœ‹åˆ°ç…§ç‰‡ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªåå‘çš„å¹³é¢
                // å¹¶ä½¿ç”¨ scale.x = -1 æ¥ä¿®æ­£é•œåƒé—®é¢˜ï¼Œç¡®ä¿æ–‡å­—/å†…å®¹æ–¹å‘æ­£ç¡®
                const backGeometry = new THREE.PlaneGeometry(4, 3);
                const backMaterial = new THREE.MeshBasicMaterial({
                    map: texture,   // ä½¿ç”¨ç›¸åŒçš„çº¹ç†
                    side: THREE.FrontSide,
                    transparent: true,
                    opacity: 0.9,
                    color: 0xffffff
                });
                const backPlane = new THREE.Mesh(backGeometry, backMaterial);
                backPlane.rotation.y = Math.PI; // æ—‹è½¬180åº¦ï¼Œé¢å‘ -Z
                backPlane.scale.x = -1;         // ä¿®æ­£é•œåƒï¼Œè®©å›¾ç‰‡çœ‹èµ·æ¥æ˜¯æ­£çš„
                backPlane.position.z = -0.03;   // <--- å…³é”®ä¿®æ”¹ï¼šç§»åˆ°ç›¸æ¡†åé¢ (-0.01) æ›´è¿œä¸€ç‚¹ï¼Œç¡®ä¿ä»èƒŒé¢çœ‹æ—¶åœ¨æœ€å‰é¢
                photoGroup.add(backPlane);

                // 3. ç…§ç‰‡è¾¹æ¡† (é‡‘è‰²)
                const frameGeometry = new THREE.PlaneGeometry(4.2, 3.2);
                const frameMaterial = new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.gold,
                    side: THREE.DoubleSide
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.z = -0.01; // æ”¾åœ¨ä¸­é—´
                photoGroup.add(frame);

                // èºæ—‹æ’åˆ—ä½ç½®
                const t = i / photoCount;
                const angle = t * Math.PI * 2.5; // ç»•ä¸€åœˆå¤š
                const radius = CONFIG.treeRadius + 3 + (1-t) * 2;
                const y = t * CONFIG.treeHeight * 0.7 + 3;

                const pX = Math.cos(angle) * radius;
                const pZ = Math.sin(angle) * radius;

                photoGroup.position.set(pX, y, pZ);
                
                // è®©ç…§ç‰‡é¢å‘å¤–ä¾§ (èƒŒå¯¹ä¸­å¿ƒ)
                // LookAt é»˜è®¤è®© +Z è½´æŒ‡å‘ç›®æ ‡
                // æˆ‘ä»¬è®© +Z (æ­£é¢) æŒ‡å‘å¤–ä¾§: ä½ç½® + å‘é‡(ä¸­å¿ƒ->ä½ç½®)
                photoGroup.lookAt(pX * 2, y, pZ * 2);

                // å­˜å‚¨å¼•ç”¨å’Œç´¢å¼•
                photoGroup.userData.photoIndex = i;
                spiralPhotoObjects.push(photoGroup);

                spiralGroup.add(photoGroup);
            }
        }

        // åˆ›å»ºé›ªèŠ±æ•ˆæœ
        function createBackgroundParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const sizes = [];
            const velocities = []; // å­˜å‚¨æ¯ä¸ªé›ªèŠ±çš„é€Ÿåº¦

            for (let i = 0; i < CONFIG.snowflakeCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 120,
                    Math.random() * 80,
                    (Math.random() - 0.5) * 120
                );
                // ä¸åŒå¤§å°çš„é›ªèŠ±
                sizes.push(0.3 + Math.random() * 0.5);
                // å­˜å‚¨é€Ÿåº¦å’Œæ‘‡æ‘†å‚æ•°
                velocities.push(
                    (Math.random() - 0.5) * 0.02, // x æ‘‡æ‘†
                    0.03 + Math.random() * 0.05,   // y ä¸‹è½é€Ÿåº¦
                    Math.random() * Math.PI * 2    // ç›¸ä½
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.userData.velocities = velocities;

            const material = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.5,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8,
                map: createSnowflakeTexture()
            });

            particleSystem = new THREE.Points(geometry, material);
            particleSystem.userData.velocities = velocities;
            scene.add(particleSystem);
        }

        // åˆ›å»ºé›ªèŠ±çº¹ç†
        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const center = 16;
            const radius = 14;

            const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(230,240,255,0.8)');
            gradient.addColorStop(0.6, 'rgba(200,220,255,0.4)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const center = 16;
            const radius = 14;
            
            const gradient = context.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.5, 'rgba(255,215,0,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 3. æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---

        function calculateDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // æŒ¥æ‰‹æ£€æµ‹
        function detectWave(currentX) {
            const now = Date.now();
            waveHistory.push({ x: currentX, time: now });

            // ä¿ç•™æœ€è¿‘500msçš„æ•°æ®
            waveHistory = waveHistory.filter(p => now - p.time < 500);

            if (waveHistory.length >= 4) {
                let directionChanges = 0;
                let lastDirection = 0;

                for (let i = 1; i < waveHistory.length; i++) {
                    const diff = waveHistory[i].x - waveHistory[i-1].x;
                    const currentDirection = diff > 0.01 ? 1 : (diff < -0.01 ? -1 : 0);

                    if (currentDirection !== 0 && currentDirection !== lastDirection && lastDirection !== 0) {
                        directionChanges++;
                    }
                    if (currentDirection !== 0) lastDirection = currentDirection;
                }

                // è‡³å°‘2æ¬¡æ–¹å‘å˜åŒ–è§†ä¸ºæŒ¥æ‰‹
                if (directionChanges >= 2 && now - lastWaveTime > 2000) {
                    lastWaveTime = now;
                    return true;
                }
            }
            return false;
        }

        // è§¦å‘ç¥ç¦åŠ¨ç”»
        function triggerBlessing() {
            blessingTextEl.textContent = blessings[blessingIndex];
            blessingIndex = (blessingIndex + 1) % blessings.length;

            blessingContainer.classList.add('active');
            blessingTextEl.style.animation = 'none';
            blessingTextEl.offsetHeight; // è§¦å‘é‡ç»˜
            blessingTextEl.style.animation = 'blessingPulse 2s ease-in-out';

            setTimeout(() => {
                blessingContainer.classList.remove('active');
            }, 2000);
        }

        // æ›´æ–°æ‰‹åŠ¿æŒ‡ç¤ºå™¨
        function updateGestureIndicators() {
            dotHand.classList.toggle('active', handVisible);
            dotMove.classList.toggle('active', handVisible && (Math.abs(swipeDeltaX) > 0.01 || Math.abs(swipeDeltaY) > 0.01));
            dotClosed.classList.toggle('active', isPinching);
        }

        // æ›´æ–°æ‰‹åŠ¿å…‰æ ‡
        function updateHandCursor(landmarks) {
            if (!landmarks) {
                handCursor.classList.remove('visible');
                return;
            }

            const palmCenter = landmarks[9]; // ä¸­æŒ‡æ ¹éƒ¨ä½œä¸ºæ‰‹å¿ƒ
            const screenX = (1 - palmCenter.x) * window.innerWidth;
            const screenY = palmCenter.y * window.innerHeight;

            handCursor.style.left = (screenX - 15) + 'px';
            handCursor.style.top = (screenY - 15) + 'px';
            handCursor.classList.add('visible');

            handCursor.classList.toggle('pinching', isPinching);
        }

        function onResults(results) {
            loadingEl.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handVisible = true;
                const landmarks = results.multiHandLandmarks[0];

                // æ›´æ–°æ‰‹åŠ¿å…‰æ ‡
                updateHandCursor(landmarks);

                // å…³é”®ç‚¹
                const wrist = landmarks[0];        // æ‰‹è…•
                const thumbTip = landmarks[4];     // æ‹‡æŒ‡å°–
                const indexTip = landmarks[8];     // é£ŸæŒ‡å°–
                const middleTip = landmarks[12];   // ä¸­æŒ‡å°–
                const ringTip = landmarks[16];     // æ— åæŒ‡å°–
                const pinkyTip = landmarks[20];    // å°æŒ‡å°–

                // === 1. æ£€æµ‹æåˆ ===
                const thumbIndexDist = calculateDistance(thumbTip, indexTip);
                isPinching = thumbIndexDist < 0.06;

                // === 2. æ£€æµ‹æ‰‹æŒå¼ å¼€ ===
                const avgTipToWrist = (
                    calculateDistance(indexTip, wrist) +
                    calculateDistance(middleTip, wrist) +
                    calculateDistance(ringTip, wrist) +
                    calculateDistance(pinkyTip, wrist)
                ) / 4;
                isHandOpen = avgTipToWrist > 0.2 && !isPinching;

                // === 3. æ£€æµ‹æ‰‹æŒä½ç½®ç§»åŠ¨ ===
                const palmCenter = landmarks[9];
                const currentX = 1 - palmCenter.x;
                const currentY = palmCenter.y;

                swipeDeltaX = (currentX - prevHandX) * 5;
                swipeDeltaY = (currentY - prevHandY) * 5;

                // === 4. æ£€æµ‹æŒ¥æ‰‹ ===
                if (isHandOpen && detectWave(currentX)) {
                    isWaving = true;
                    triggerBlessing();
                }

                prevHandX = currentX;
                prevHandY = currentY;
                handX = currentX;
                handY = currentY;

                updateAppLogic();
                updateGestureIndicators();

                // Debug
                debugEl.innerText = `æåˆ: ${isPinching ? 'æ˜¯' : 'å¦'} | å¼ å¼€: ${isHandOpen ? 'æ˜¯' : 'å¦'}`;
            } else {
                handVisible = false;
                swipeDeltaX = 0;
                swipeDeltaY = 0;

                handCursor.classList.remove('visible');
                updateGestureIndicators();

                // æ— æ‰‹åŠ¿æ—¶å›åˆ° IDLE
                if (currentState !== STATE.IDLE) {
                    currentState = STATE.IDLE;
                    statusEl.innerText = "çŠ¶æ€: ç­‰å¾…æ‰‹åŠ¿";
                    instructionEl.innerText = "ä¸¾èµ·æ‰‹å¼€å§‹äº¤äº’";
                    iconEl.innerText = "âœ‹";
                    overlayEl.classList.remove('active');  // éšè—å›¾ç‰‡
                    targetSnowSpeed = 1;  // æ¢å¤é›ªèŠ±é€Ÿåº¦
                }

                debugEl.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
            }
        }

        // è®°å½•ä¸Šä¸€æ¬¡æ˜¯å¦æåˆï¼Œç”¨äºæ£€æµ‹æåˆå¼€å§‹
        let wasPinching = false;

        function updateAppLogic() {
            // çŠ¶æ€æœº - ç®€åŒ–çš„é€»è¾‘

            // ä¼˜å…ˆçº§ 1: æåˆ -> æ”¾æ…¢é›ªèŠ± + å±•ç¤ºå›¾ç‰‡
            if (isPinching) {
                // åˆšå¼€å§‹æåˆæ—¶è®¡ç®—æœ€è¿‘çš„å›¾ç‰‡å¹¶å±•ç¤º
                if (!wasPinching) {
                    // === æ–°å¢ï¼šå°è¯•ä½¿ç”¨å°„çº¿æ£€æµ‹é€‰ä¸­çš„ç…§ç‰‡ ===
                    const raycaster = new THREE.Raycaster();
                    const pointer = new THREE.Vector2();
                    
                    // handX/Y æ˜¯ 0-1 (å·¦ä¸Šè§’åŸç‚¹)ï¼Œè½¬æ¢ä¸º NDC -1 åˆ° 1 (ä¸­å¿ƒåŸç‚¹)
                    pointer.x = (handX * 2) - 1;
                    pointer.y = -(handY * 2) + 1;

                    raycaster.setFromCamera(pointer, camera);
                    
                    // æ£€æµ‹æ˜¯å¦ç‚¹å‡»åˆ°äº†ç…§ç‰‡ (é€’å½’æ£€æµ‹ spiralPhotoObjects çš„å­ç‰©ä½“)
                    const intersects = raycaster.intersectObjects(spiralPhotoObjects, true);
                    
                    let selectedIndex = -1;

                    if (intersects.length > 0) {
                        // æ‰¾åˆ°å‘½ä¸­çš„ç‰©ä½“ï¼Œå‘ä¸ŠæŸ¥æ‰¾åŒ…å« photoIndex çš„ç»„
                        let target = intersects[0].object;
                        while (target && target !== scene && target.userData.photoIndex === undefined) {
                            target = target.parent;
                        }
                        
                        if (target && target.userData.photoIndex !== undefined) {
                            selectedIndex = target.userData.photoIndex;
                            statusEl.innerText = "é€‰ä¸­ç…§ç‰‡ (" + (selectedIndex + 1) + "/" + PHOTOS.length + ")";
                        }
                    }

                    if (selectedIndex !== -1) {
                        // å¦‚æœå°„çº¿é€‰ä¸­äº†ç…§ç‰‡ï¼Œä½¿ç”¨è¯¥ç…§ç‰‡
                        currentPhotoIndex = selectedIndex;
                    } else {
                        // === é™çº§æ–¹æ¡ˆï¼šå¦‚æœæ²¡æœ‰é€‰ä¸­ä»»ä½•ç…§ç‰‡ï¼Œä½¿ç”¨è·ç¦»æ‘„åƒæœºæœ€è¿‘çš„ ===
                        let minDistance = Infinity;
                        let closestIndex = 0;
                        
                        const cameraPos = camera.position;
                        const worldPos = new THREE.Vector3();

                        spiralPhotoObjects.forEach(group => {
                            // è·å–ç…§ç‰‡çš„ä¸–ç•Œåæ ‡
                            group.getWorldPosition(worldPos);
                            const dist = worldPos.distanceTo(cameraPos);
                            
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestIndex = group.userData.photoIndex;
                            }
                        });

                        currentPhotoIndex = closestIndex;
                        statusEl.innerText = "æœ€è¿‘ç…§ç‰‡ (" + (currentPhotoIndex + 1) + "/" + PHOTOS.length + ")";
                    }
                    
                    // === æ ¹æ®å›¾ç‰‡æ¯”ä¾‹è°ƒæ•´å±•ç¤ºæ¡† ===
                    const targetObj = spiralPhotoObjects.find(o => o.userData.photoIndex === currentPhotoIndex);
                    if (targetObj && targetObj.userData.aspectRatio) {
                        const aspect = targetObj.userData.aspectRatio;
                        overlayEl.style.aspectRatio = aspect;
                        
                        if (aspect >= 1) {
                            // æ¨ªå±å›¾ç‰‡ï¼šå®½åº¦ä¼˜å…ˆ
                            overlayEl.style.width = '80%';
                            overlayEl.style.height = 'auto';
                            overlayEl.style.maxWidth = '600px';
                        } else {
                            // ç«–å±å›¾ç‰‡ï¼šé«˜åº¦ä¼˜å…ˆ
                            overlayEl.style.width = 'auto';
                            overlayEl.style.height = '70%'; // å æ®å±å¹•é«˜åº¦çš„ 70%
                            overlayEl.style.maxWidth = 'none';
                        }
                    } else {
                        // é»˜è®¤å…œåº•
                        overlayEl.style.aspectRatio = '16/9';
                        overlayEl.style.width = '80%';
                        overlayEl.style.height = 'auto';
                    }

                    overlayImage.src = PHOTOS[currentPhotoIndex];
                }
                currentState = STATE.CLOSED;
                // statusEl.innerText åœ¨ä¸Šé¢è®¾ç½®äº†åŒºåˆ†é€‰ä¸­æ–¹å¼
                instructionEl.innerText = "æ¾å¼€åæ—‹è½¬é€‰æ‹©å…¶ä»–å›¾ç‰‡";
                iconEl.innerText = "ğŸ‘Œ";
                overlayEl.classList.add('active');
                targetSnowSpeed = 0.3; // é›ªèŠ±å‡é€Ÿ
            }
            // ä¼˜å…ˆçº§ 2: æ‰‹æŒå‡ºç°å³è¿›å…¥äº¤äº’æ¨¡å¼
            else if (handVisible) {
                currentState = STATE.INTERACTIVE;
                statusEl.innerText = "äº¤äº’æ¨¡å¼";
                instructionEl.innerText = "ç§»åŠ¨æ§åˆ¶è§†è§’ | æåˆå±•ç¤ºå›¾ç‰‡ | æŒ¥æ‰‹é€ç¥ç¦";
                iconEl.innerText = "ğŸ–ï¸";
                overlayEl.classList.remove('active');
                targetSnowSpeed = 1;
            }

            wasPinching = isPinching;

            // æ‰‹æŒç§»åŠ¨æ§åˆ¶ï¼ˆä»…åœ¨äº¤äº’æ¨¡å¼ä¸‹ç”Ÿæ•ˆï¼‰
            if (currentState === STATE.INTERACTIVE) {
                // å·¦å³ç§»åŠ¨ -> æ—‹è½¬åœºæ™¯
                if (Math.abs(swipeDeltaX) > 0.008) {
                    targetGroupRotation += swipeDeltaX * 2.5;
                }

                // ä¸Šä¸‹ç§»åŠ¨ -> æ§åˆ¶æ‘„åƒæœºè·ç¦»
                if (Math.abs(swipeDeltaY) > 0.008) {
                    targetCameraZ += swipeDeltaY * 15;
                    targetCameraZ = Math.max(15, Math.min(50, targetCameraZ));

                    targetCameraY -= swipeDeltaY * 5;
                    targetCameraY = Math.max(5, Math.min(15, targetCameraY));
                }
            }
        }

        // --- 4. åŠ¨ç”»å¾ªç¯ ---

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // å¹³æ»‘è¿‡æ¸¡é›ªèŠ±é€Ÿåº¦
            snowSpeedMultiplier += (targetSnowSpeed - snowSpeedMultiplier) * 0.1;

            // 1. åœ£è¯æ ‘è‡ªè½¬
            if (scene.userData.treeGroup) {
                const currentRot = scene.userData.treeGroup.rotation.y;
                scene.userData.treeGroup.rotation.y += (targetGroupRotation - currentRot) * 0.05;
                // æ— æ‰‹åŠ¿æ—¶ç¼“æ…¢è‡ªè½¬
                if (!handVisible) {
                    targetGroupRotation += 0.002;
                }
                spiralGroup.rotation.y = scene.userData.treeGroup.rotation.y;
            }

            // 2. æ—‹è½¬å…‰æºåŠ¨ç”»
            if (rotatingLight) {
                const lightAngle = time * 0.3;
                rotatingLight.position.x = Math.cos(lightAngle) * 18;
                rotatingLight.position.z = Math.sin(lightAngle) * 18;
                rotatingLight.position.y = 10 + Math.sin(time * 0.5) * 3;
                rotatingLight.intensity = 0.8;
            }

            // 3. ç²’å­é—ªçƒåŠ¨ç”»
            if (treeParticles) {
                const sizes = treeParticles.geometry.attributes.size.array;
                for (let i = 0; i < sizes.length; i++) {
                    const baseSize = 0.25 + (i % 10) * 0.02;
                    sizes[i] = baseSize + Math.sin(time * 2 + i * 0.1) * 0.08;
                }
                treeParticles.geometry.attributes.size.needsUpdate = true;
            }

            // 4. å½©ç¯ä¸²é—ªçƒ
            if (lightString) {
                lightString.material.size = 0.5 + Math.sin(time * 4) * 0.2;
            }

            // 5. æ˜Ÿæ˜Ÿç²’å­åŠ¨ç”»
            if (starParticles) {
                starParticles.rotation.y += 0.005; // ç¼“æ…¢è‡ªè½¬

                const sizes = starParticles.geometry.attributes.size.array;
                const initialSizes = starParticles.geometry.userData.initialSizes;
                
                for (let i = 0; i < sizes.length; i++) {
                    // ç²’å­å¤§å°çš„è„‰åŠ¨æ•ˆæœï¼Œäº§ç”Ÿé—ªçƒæ„Ÿ
                    sizes[i] = initialSizes[i] * (1 + Math.sin(time * 4 + i) * 0.1);
                }
                starParticles.geometry.attributes.size.needsUpdate = true;
            }

            // 6. å½©çƒ(ç²’å­ç‰ˆ)è½»å¾®æ‘‡æ‘†
            if (ornamentParticles) {
                const positions = ornamentParticles.geometry.attributes.position.array;
                const phases = ornamentParticles.geometry.attributes.phase.array;
                const originalPositions = ornamentParticles.geometry.userData.originalPositions;

                for (let i = 0; i < positions.length / 3; i++) {
                    const yIdx = i * 3 + 1;
                    const phase = phases[i];
                    // åŸºäºåŸå§‹ä½ç½®ä¸Šä¸‹æµ®åŠ¨
                    positions[yIdx] = originalPositions[yIdx] + Math.sin(time * 1.5 + phase) * 0.08;
                }
                ornamentParticles.geometry.attributes.position.needsUpdate = true;
                
                // é—ªçƒæ•ˆæœ
                const sizes = ornamentParticles.geometry.attributes.size.array;
                for(let i=0; i < sizes.length; i++) {
                     // åŸºç¡€å¤§å° + å‘¼å¸é—ªçƒ
                     sizes[i] = (1.5 + Math.sin(time * 2 + i) * 0.3) * (1 + Math.random() * 0.1);
                }
                ornamentParticles.geometry.attributes.size.needsUpdate = true;
            }

            // 7. ç¤¼ç‰©ç›’å¾®å¾®èµ·ä¼
            giftBoxes.forEach((box, idx) => {
                const phase = box.userData.phase;
                box.position.y = box.userData.originalY + Math.sin(time * 0.8 + phase) * 0.05;
            });

            // 8. æ‘„åƒæœºåŠ¨æ€ä½ç§» - åŸºäºæ‰‹åŠ¿æ§åˆ¶
            let targetPos;
            if (currentState === STATE.CLOSED) {
                // é—­åˆæ‰‹åŠ¿æ—¶ä¿æŒå½“å‰ä½ç½®
                targetPos = camera.position.clone();
            } else if (currentState === STATE.IDLE) {
                // æ— æ‰‹åŠ¿æ—¶å›åˆ°è¿œæ™¯
                targetCameraZ += (35 - targetCameraZ) * 0.02;
                targetCameraY += (10 - targetCameraY) * 0.02;
                targetPos = new THREE.Vector3(0, targetCameraY, targetCameraZ);
            } else {
                // äº¤äº’æ¨¡å¼ - ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶çš„æ‘„åƒæœºä½ç½®
                targetPos = new THREE.Vector3(0, targetCameraY, targetCameraZ);
            }

            camera.position.lerp(targetPos, 0.06);
            camera.lookAt(0, 8, 0);

            // 9. é›ªèŠ±é£˜è½åŠ¨ç”» - æ”¯æŒé€Ÿåº¦æ§åˆ¶
            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                const velocities = particleSystem.userData.velocities;

                for (let i = 0; i < positions.length / 3; i++) {
                    const idx = i * 3;
                    const velIdx = i * 3;

                    // æ°´å¹³æ‘‡æ‘†
                    positions[idx] += Math.sin(time + velocities[velIdx + 2]) * velocities[velIdx];

                    // å‚ç›´ä¸‹è½ - åº”ç”¨é€Ÿåº¦å€ç‡
                    positions[idx + 1] -= velocities[velIdx + 1] * snowSpeedMultiplier;

                    // é‡ç½®åˆ°é¡¶éƒ¨
                    if (positions[idx + 1] < -10) {
                        positions[idx + 1] = 70;
                        positions[idx] = (Math.random() - 0.5) * 120;
                        positions[idx + 2] = (Math.random() - 0.5) * 120;
                    }
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;

                // é›ªèŠ±æè´¨å¤§å°éšé€Ÿåº¦å˜åŒ–
                particleSystem.material.size = 0.4 + snowSpeedMultiplier * 0.1;
                particleSystem.material.opacity = 0.7 + snowSpeedMultiplier * 0.08;

                particleSystem.rotation.y = -scene.userData.treeGroup.rotation.y * 0.1;
            }

            renderer.render(scene, camera);
        }

        // --- 5. å¯åŠ¨ MediaPipe ---
        
        async function startApp() {
            initScene();

            const videoElement = document.getElementById('input-video');
            
            const hands = new Hands({locateFile: (file) => {
                return `${mpAssetBase}${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            try {
                await cameraUtils.start();
                animate();
            } catch (e) {
                console.error(e);
                loadingEl.innerHTML = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·æ£€æŸ¥æƒé™æˆ–ä½¿ç”¨ HTTPS";
            }
        }

        // --- 6. éŸ³ä¹æ§åˆ¶ ---

        function initAudio() {
            if (bgMusic) return;

            bgMusic = new Audio('Christmas_eve.mp3');
            bgMusic.volume = 0.5;
            bgMusic.loop = true;  // å¾ªç¯æ’­æ”¾

            // åŠ è½½é”™è¯¯å¤„ç†
            bgMusic.addEventListener('error', (e) => {
                console.error('éŸ³ä¹åŠ è½½å¤±è´¥:', e);
                musicHint.textContent = 'éŸ³ä¹åŠ è½½å¤±è´¥';
                musicHint.classList.add('show');
            });

            // å¯ä»¥æ’­æ”¾æ—¶æ›´æ–°æç¤º
            bgMusic.addEventListener('canplay', () => {
                if (isMusicPlaying) {
                    musicHint.textContent = 'æ­£åœ¨æ’­æ”¾: Christmas Eve';
                    musicHint.classList.add('show');
                    setTimeout(() => musicHint.classList.remove('show'), 3000);
                }
            });
        }

        function startMusic() {
            if (isMusicPlaying) return;

            initAudio();

            bgMusic.play().then(() => {
                isMusicPlaying = true;
                musicBtn.textContent = 'ğŸ”Š';
                musicBtn.classList.add('playing');
                musicHint.textContent = 'æ­£åœ¨æ’­æ”¾: Christmas Eve';
                musicHint.classList.add('show');
                setTimeout(() => musicHint.classList.remove('show'), 3000);
            }).catch(e => {
                console.log('éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½æ’­æ”¾:', e);
                musicHint.textContent = 'ç‚¹å‡»æŒ‰é’®æ’­æ”¾éŸ³ä¹';
                musicHint.classList.add('show');
            });
        }

        function stopMusic() {
            if (!bgMusic) return;

            bgMusic.pause();
            isMusicPlaying = false;
            musicBtn.textContent = 'ğŸ”‡';
            musicBtn.classList.remove('playing');
            musicHint.textContent = 'ç‚¹å‡»æ’­æ”¾åœ£è¯éŸ³ä¹';
        }

        function toggleMusic() {
            if (isMusicPlaying) {
                stopMusic();
            } else {
                startMusic();
            }
        }

        // ç»‘å®šéŸ³ä¹æŒ‰é’®äº‹ä»¶
        musicBtn.addEventListener('click', toggleMusic);

        // é¡µé¢é¦–æ¬¡äº¤äº’æ—¶è‡ªåŠ¨æ’­æ”¾éŸ³ä¹
        let hasAutoPlayed = false;
        function tryAutoPlayMusic() {
            if (hasAutoPlayed) return;
            hasAutoPlayed = true;
            startMusic();
            // ç§»é™¤äº‹ä»¶ç›‘å¬
            document.removeEventListener('click', tryAutoPlayMusic);
            document.removeEventListener('touchstart', tryAutoPlayMusic);
        }

        // ç›‘å¬ç”¨æˆ·é¦–æ¬¡äº¤äº’ä»¥è§¦å‘è‡ªåŠ¨æ’­æ”¾
        document.addEventListener('click', tryAutoPlayMusic);
        document.addEventListener('touchstart', tryAutoPlayMusic);

        // è‡ªåŠ¨æ£€æµ‹å›¾ç‰‡å¹¶å¯åŠ¨
        async function autoDetectPhotos() {
            loadingEl.innerHTML = "æ­£åœ¨æ£€æµ‹å›¾ç‰‡èµ„æº...";
            let index = 1;
            const maxPhotos = 100; // å®‰å…¨ä¸Šé™ï¼Œé˜²æ­¢æ— é™å¾ªç¯

            while (index <= maxPhotos) {
                const path = `assets/${index}.jpg`;
                try {
                    // ä½¿ç”¨ HEAD è¯·æ±‚æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    const res = await fetch(path, { method: 'HEAD' });
                    if (res.ok) {
                        PHOTOS.push(path);
                        index++;
                    } else {
                        break; // é‡åˆ° 404 æˆ–å…¶ä»–é”™è¯¯ï¼Œåœæ­¢æ£€æµ‹
                    }
                } catch (e) {
                    console.log("å›¾ç‰‡æ£€æµ‹ç»“æŸ:", e);
                    break;
                }
            }

            console.log(`æ£€æµ‹åˆ° ${PHOTOS.length} å¼ ç…§ç‰‡`);
            if (PHOTOS.length === 0) {
                loadingEl.innerHTML = "æœªæ£€æµ‹åˆ° assets/X.jpg å›¾ç‰‡<br>è¯·ç¡®ä¿å›¾ç‰‡å‘½åä¸º 1.jpg, 2.jpg...";
                // ä¹Ÿå¯ä»¥æ”¾ä¸€äº›é»˜è®¤å ä½å›¾ï¼Œæˆ–è€…å°±åœæ­¢
            }
            
            startApp();
        }

        // å¯åŠ¨æµç¨‹ï¼šæ£€æµ‹ç¯å¢ƒ -> åŠ è½½è„šæœ¬ -> æ£€æµ‹å›¾ç‰‡ -> å¯åŠ¨åº”ç”¨
        initEnvironment().then(() => {
            autoDetectPhotos();
        });

    </script>
</body>
</html>